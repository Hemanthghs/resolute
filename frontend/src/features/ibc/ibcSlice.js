import { createAsyncThunk, createSlice } from "@reduxjs/toolkit";
import { setError, setTxHash } from "../common/commonSlice";
import { signAndBroadcast } from "../../utils/signing";
import { IBCTransferMsg } from "../../txns/ibc/IbcTransfer";
import ibcService from "./ibcService";

const initialState = {
  // state.chains[chainID].status = "pending" | "rejected" | "idle"

  chains: {},
};

export const txIBCTransfer = createAsyncThunk(
  "ibc/transfer",
  async (data, { rejectWithValue, fulfillWithValue, dispatch }) => {
    try {
      const consensusStateResponse = await ibcService.consensusState(data.rpc);
      const timeout_BlockHeight = consensusStateResponse?.data?.result?.response?.last_block_height + 150 || 150 ;
      const msg = IBCTransferMsg(
        data.from,
        data.to,
        data.amount,
        data.assetMinimalDenom,
        data.sourcePort,
        data.sourceChannel,
        timeout_BlockHeight,
      );
      const result = await signAndBroadcast(
        data.chainID,
        data.aminoConfig,
        data.prefix,
        [msg],
        860000,
        "",
        `${data.feeAmount}${data.minimalDenom}`,
        data.rest,
        data.feegranter?.length > 0 ? data.feegranter : undefined
      );
      if (result?.code === 0) {
        dispatch(
          setTxHash({
            hash: result?.transactionHash,
          })
        );
        return fulfillWithValue({ txHash: result?.transactionHash });
      } else {
        dispatch(
          setError({
            type: "error",
            message: result?.rawLog,
          })
        );
        return rejectWithValue(result?.rawLog);
      }
    } catch (error) {
      dispatch(
        setError({
          type: "error",
          message: error.message,
        })
      );
      return rejectWithValue(error.message);
    }
  }
);

export const ibcSlice = createSlice({
  name: "ibc",
  initialState,
  reducers: {},
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(txIBCTransfer.pending, (state, action) => {
        const chainID = action.meta.arg.chainID;
        const ibcStatus = {
          status: "pending",
        };
        state.chains[chainID] = ibcStatus;
      })
      .addCase(txIBCTransfer.fulfilled, (state, action) => {
        const chainID = action.meta.arg.chainID;
        const ibcStatus = {
          status: "idle",
        };
        state.chains[chainID] = ibcStatus;
      })
      .addCase(txIBCTransfer.rejected, (state, action) => {
        const chainID = action.meta.arg.chainID;
        const ibcStatus = {
          status: "rejected",
        };
        state.chains[chainID] = ibcStatus;
      });
  },
});

export default ibcSlice.reducer;
